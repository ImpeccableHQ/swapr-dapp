/* tslint:disable */
/* eslint-disable */
/**
 * Movr Aggregator API
 * The Movr Aggregator API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import {
  ActiveRoutesOutputDTO,
  ActiveRoutesOutputDTOFromJSON,
  ActiveRoutesOutputDTOToJSON,
  NextTxOutputDTO,
  NextTxOutputDTOFromJSON,
  NextTxOutputDTOToJSON,
  RouteStatusOutputDTO,
  RouteStatusOutputDTOFromJSON,
  RouteStatusOutputDTOToJSON,
  StartActiveRouteInputDTO,
  StartActiveRouteInputDTOFromJSON,
  StartActiveRouteInputDTOToJSON,
  StartActiveRouteResponseDTO,
  StartActiveRouteResponseDTOFromJSON,
  StartActiveRouteResponseDTOToJSON,
} from '../models'

export interface ActiveRoutesControllerGetActiveRouteStatusRequest {
  activeRouteId: string
  userTxIndex: string
  txHash?: string
  signature?: string
  aPIKEY?: string
}

export interface ActiveRoutesControllerGetActiveRoutesRequest {
  activeRouteId: string
  aPIKEY?: string
}

export interface ActiveRoutesControllerGetActiveRoutesForUserRequest {
  userAddress: string
  sort?: ActiveRoutesControllerGetActiveRoutesForUserSortEnum
  offset?: string
  limit?: string
  routeStatus?: ActiveRoutesControllerGetActiveRoutesForUserRouteStatusEnum
  fromChainId?: string
  toChainId?: string
  fromTokenAddress?: string
  toTokenAddress?: string
  aPIKEY?: string
}

export interface ActiveRoutesControllerNextTxRequest {
  activeRouteId: string
  aPIKEY?: string
}

export interface ActiveRoutesControllerStartActiveRouteRequest {
  startActiveRouteInputDTO: StartActiveRouteInputDTO
  aPIKEY?: string
}

/**
 *
 */
export class RoutesApi extends runtime.BaseAPI {
  /**
   */
  async activeRoutesControllerGetActiveRouteStatusRaw(
    requestParameters: ActiveRoutesControllerGetActiveRouteStatusRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<RouteStatusOutputDTO>> {
    if (requestParameters.activeRouteId === null || requestParameters.activeRouteId === undefined) {
      throw new runtime.RequiredError(
        'activeRouteId',
        'Required parameter requestParameters.activeRouteId was null or undefined when calling activeRoutesControllerGetActiveRouteStatus.'
      )
    }

    if (requestParameters.userTxIndex === null || requestParameters.userTxIndex === undefined) {
      throw new runtime.RequiredError(
        'userTxIndex',
        'Required parameter requestParameters.userTxIndex was null or undefined when calling activeRoutesControllerGetActiveRouteStatus.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.activeRouteId !== undefined) {
      queryParameters['activeRouteId'] = requestParameters.activeRouteId
    }

    if (requestParameters.userTxIndex !== undefined) {
      queryParameters['userTxIndex'] = requestParameters.userTxIndex
    }

    if (requestParameters.txHash !== undefined) {
      queryParameters['txHash'] = requestParameters.txHash
    }

    if (requestParameters.signature !== undefined) {
      queryParameters['signature'] = requestParameters.signature
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
      headerParameters['API-KEY'] = String(requestParameters.aPIKEY)
    }

    const response = await this.request(
      {
        path: `/v2/route/prepare`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => RouteStatusOutputDTOFromJSON(jsonValue))
  }

  /**
   */
  async activeRoutesControllerGetActiveRouteStatus(
    requestParameters: ActiveRoutesControllerGetActiveRouteStatusRequest,
    initOverrides?: RequestInit
  ): Promise<RouteStatusOutputDTO> {
    const response = await this.activeRoutesControllerGetActiveRouteStatusRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async activeRoutesControllerGetActiveRoutesRaw(
    requestParameters: ActiveRoutesControllerGetActiveRoutesRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ActiveRoutesOutputDTO>> {
    if (requestParameters.activeRouteId === null || requestParameters.activeRouteId === undefined) {
      throw new runtime.RequiredError(
        'activeRouteId',
        'Required parameter requestParameters.activeRouteId was null or undefined when calling activeRoutesControllerGetActiveRoutes.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.activeRouteId !== undefined) {
      queryParameters['activeRouteId'] = requestParameters.activeRouteId
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
      headerParameters['API-KEY'] = String(requestParameters.aPIKEY)
    }

    const response = await this.request(
      {
        path: `/v2/route/active-routes`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => ActiveRoutesOutputDTOFromJSON(jsonValue))
  }

  /**
   */
  async activeRoutesControllerGetActiveRoutes(
    requestParameters: ActiveRoutesControllerGetActiveRoutesRequest,
    initOverrides?: RequestInit
  ): Promise<ActiveRoutesOutputDTO> {
    const response = await this.activeRoutesControllerGetActiveRoutesRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async activeRoutesControllerGetActiveRoutesForUserRaw(
    requestParameters: ActiveRoutesControllerGetActiveRoutesForUserRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ActiveRoutesOutputDTO>> {
    if (requestParameters.userAddress === null || requestParameters.userAddress === undefined) {
      throw new runtime.RequiredError(
        'userAddress',
        'Required parameter requestParameters.userAddress was null or undefined when calling activeRoutesControllerGetActiveRoutesForUser.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.userAddress !== undefined) {
      queryParameters['userAddress'] = requestParameters.userAddress
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.offset !== undefined) {
      queryParameters['offset'] = requestParameters.offset
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit
    }

    if (requestParameters.routeStatus !== undefined) {
      queryParameters['routeStatus'] = requestParameters.routeStatus
    }

    if (requestParameters.fromChainId !== undefined) {
      queryParameters['fromChainId'] = requestParameters.fromChainId
    }

    if (requestParameters.toChainId !== undefined) {
      queryParameters['toChainId'] = requestParameters.toChainId
    }

    if (requestParameters.fromTokenAddress !== undefined) {
      queryParameters['fromTokenAddress'] = requestParameters.fromTokenAddress
    }

    if (requestParameters.toTokenAddress !== undefined) {
      queryParameters['toTokenAddress'] = requestParameters.toTokenAddress
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
      headerParameters['API-KEY'] = String(requestParameters.aPIKEY)
    }

    const response = await this.request(
      {
        path: `/v2/route/active-routes/users`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => ActiveRoutesOutputDTOFromJSON(jsonValue))
  }

  /**
   */
  async activeRoutesControllerGetActiveRoutesForUser(
    requestParameters: ActiveRoutesControllerGetActiveRoutesForUserRequest,
    initOverrides?: RequestInit
  ): Promise<ActiveRoutesOutputDTO> {
    const response = await this.activeRoutesControllerGetActiveRoutesForUserRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async activeRoutesControllerNextTxRaw(
    requestParameters: ActiveRoutesControllerNextTxRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<NextTxOutputDTO>> {
    if (requestParameters.activeRouteId === null || requestParameters.activeRouteId === undefined) {
      throw new runtime.RequiredError(
        'activeRouteId',
        'Required parameter requestParameters.activeRouteId was null or undefined when calling activeRoutesControllerNextTx.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.activeRouteId !== undefined) {
      queryParameters['activeRouteId'] = requestParameters.activeRouteId
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
      headerParameters['API-KEY'] = String(requestParameters.aPIKEY)
    }

    const response = await this.request(
      {
        path: `/v2/route/build-next-tx`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => NextTxOutputDTOFromJSON(jsonValue))
  }

  /**
   */
  async activeRoutesControllerNextTx(
    requestParameters: ActiveRoutesControllerNextTxRequest,
    initOverrides?: RequestInit
  ): Promise<NextTxOutputDTO> {
    const response = await this.activeRoutesControllerNextTxRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Function that takes in a route and starts the selected route.   Function is responsible for   - Saving the selected route to bridge tokens from one chain to another.   - Saving the fromChain, toChain, and fromAsssetAddress and toAssetAddress   - Returns the Active Route Id, Current Tx, Total number of txs, txType
   */
  async activeRoutesControllerStartActiveRouteRaw(
    requestParameters: ActiveRoutesControllerStartActiveRouteRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<StartActiveRouteResponseDTO>> {
    if (
      requestParameters.startActiveRouteInputDTO === null ||
      requestParameters.startActiveRouteInputDTO === undefined
    ) {
      throw new runtime.RequiredError(
        'startActiveRouteInputDTO',
        'Required parameter requestParameters.startActiveRouteInputDTO was null or undefined when calling activeRoutesControllerStartActiveRoute.'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
      headerParameters['API-KEY'] = String(requestParameters.aPIKEY)
    }

    const response = await this.request(
      {
        path: `/v2/route/start`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: StartActiveRouteInputDTOToJSON(requestParameters.startActiveRouteInputDTO),
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => StartActiveRouteResponseDTOFromJSON(jsonValue))
  }

  /**
   * Function that takes in a route and starts the selected route.   Function is responsible for   - Saving the selected route to bridge tokens from one chain to another.   - Saving the fromChain, toChain, and fromAsssetAddress and toAssetAddress   - Returns the Active Route Id, Current Tx, Total number of txs, txType
   */
  async activeRoutesControllerStartActiveRoute(
    requestParameters: ActiveRoutesControllerStartActiveRouteRequest,
    initOverrides?: RequestInit
  ): Promise<StartActiveRouteResponseDTO> {
    const response = await this.activeRoutesControllerStartActiveRouteRaw(requestParameters, initOverrides)
    return await response.value()
  }
}

/**
 * @export
 * @enum {string}
 */
export enum ActiveRoutesControllerGetActiveRoutesForUserSortEnum {
  UpdatedAt = 'updatedAt',
  CreatedAt = 'createdAt',
}
/**
 * @export
 * @enum {string}
 */
export enum ActiveRoutesControllerGetActiveRoutesForUserRouteStatusEnum {
  Pending = 'PENDING',
  Completed = 'COMPLETED',
}
