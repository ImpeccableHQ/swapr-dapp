/* tslint:disable */
/* eslint-disable */
/**
 * Movr Aggregator API
 * The Movr Aggregator API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import { QuoteOutputDTO, QuoteOutputDTOFromJSON, QuoteOutputDTOToJSON } from '../models'

export interface QuoteControllerGetQuoteRequest {
  fromChainId: string
  fromTokenAddress: string
  toChainId: string
  toTokenAddress: string
  fromAmount: string
  userAddress: string
  uniqueRoutesPerBridge: boolean
  sort: QuoteControllerGetQuoteSortEnum
  disableSwapping?: boolean
  includeDexes?: QuoteControllerGetQuoteIncludeDexesEnum
  excludeDexes?: QuoteControllerGetQuoteExcludeDexesEnum
  includeBridges?: Array<QuoteControllerGetQuoteIncludeBridgesEnum>
  excludeBridges?: Array<QuoteControllerGetQuoteExcludeBridgesEnum>
  maxUserTxs?: string
  singleTxOnly?: boolean
  aPIKEY?: string
}

/**
 *
 */
export class QuoteApi extends runtime.BaseAPI {
  /**
   */
  async quoteControllerGetQuoteRaw(
    requestParameters: QuoteControllerGetQuoteRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<QuoteOutputDTO>> {
    if (requestParameters.fromChainId === null || requestParameters.fromChainId === undefined) {
      throw new runtime.RequiredError(
        'fromChainId',
        'Required parameter requestParameters.fromChainId was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    if (requestParameters.fromTokenAddress === null || requestParameters.fromTokenAddress === undefined) {
      throw new runtime.RequiredError(
        'fromTokenAddress',
        'Required parameter requestParameters.fromTokenAddress was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    if (requestParameters.toChainId === null || requestParameters.toChainId === undefined) {
      throw new runtime.RequiredError(
        'toChainId',
        'Required parameter requestParameters.toChainId was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    if (requestParameters.toTokenAddress === null || requestParameters.toTokenAddress === undefined) {
      throw new runtime.RequiredError(
        'toTokenAddress',
        'Required parameter requestParameters.toTokenAddress was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    if (requestParameters.fromAmount === null || requestParameters.fromAmount === undefined) {
      throw new runtime.RequiredError(
        'fromAmount',
        'Required parameter requestParameters.fromAmount was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    if (requestParameters.userAddress === null || requestParameters.userAddress === undefined) {
      throw new runtime.RequiredError(
        'userAddress',
        'Required parameter requestParameters.userAddress was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    if (requestParameters.uniqueRoutesPerBridge === null || requestParameters.uniqueRoutesPerBridge === undefined) {
      throw new runtime.RequiredError(
        'uniqueRoutesPerBridge',
        'Required parameter requestParameters.uniqueRoutesPerBridge was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    if (requestParameters.sort === null || requestParameters.sort === undefined) {
      throw new runtime.RequiredError(
        'sort',
        'Required parameter requestParameters.sort was null or undefined when calling quoteControllerGetQuote.'
      )
    }

    const queryParameters: any = {}

    if (requestParameters.fromChainId !== undefined) {
      queryParameters['fromChainId'] = requestParameters.fromChainId
    }

    if (requestParameters.fromTokenAddress !== undefined) {
      queryParameters['fromTokenAddress'] = requestParameters.fromTokenAddress
    }

    if (requestParameters.toChainId !== undefined) {
      queryParameters['toChainId'] = requestParameters.toChainId
    }

    if (requestParameters.toTokenAddress !== undefined) {
      queryParameters['toTokenAddress'] = requestParameters.toTokenAddress
    }

    if (requestParameters.fromAmount !== undefined) {
      queryParameters['fromAmount'] = requestParameters.fromAmount
    }

    if (requestParameters.userAddress !== undefined) {
      queryParameters['userAddress'] = requestParameters.userAddress
    }

    if (requestParameters.uniqueRoutesPerBridge !== undefined) {
      queryParameters['uniqueRoutesPerBridge'] = requestParameters.uniqueRoutesPerBridge
    }

    if (requestParameters.disableSwapping !== undefined) {
      queryParameters['disableSwapping'] = requestParameters.disableSwapping
    }

    if (requestParameters.includeDexes !== undefined) {
      queryParameters['includeDexes'] = requestParameters.includeDexes
    }

    if (requestParameters.excludeDexes !== undefined) {
      queryParameters['excludeDexes'] = requestParameters.excludeDexes
    }

    if (requestParameters.includeBridges) {
      queryParameters['includeBridges'] = requestParameters.includeBridges
    }

    if (requestParameters.excludeBridges) {
      queryParameters['excludeBridges'] = requestParameters.excludeBridges
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.maxUserTxs !== undefined) {
      queryParameters['maxUserTxs'] = requestParameters.maxUserTxs
    }

    if (requestParameters.singleTxOnly !== undefined) {
      queryParameters['singleTxOnly'] = requestParameters.singleTxOnly
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (requestParameters.aPIKEY !== undefined && requestParameters.aPIKEY !== null) {
      headerParameters['API-KEY'] = String(requestParameters.aPIKEY)
    }

    const response = await this.request(
      {
        path: `/v2/quote`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, jsonValue => QuoteOutputDTOFromJSON(jsonValue))
  }

  /**
   */
  async quoteControllerGetQuote(
    requestParameters: QuoteControllerGetQuoteRequest,
    initOverrides?: RequestInit
  ): Promise<QuoteOutputDTO> {
    const response = await this.quoteControllerGetQuoteRaw(requestParameters, initOverrides)
    return await response.value()
  }
}

/**
 * @export
 * @enum {string}
 */
export enum QuoteControllerGetQuoteSortEnum {
  Output = 'output',
  Gas = 'gas',
  Time = 'time',
}
/**
 * @export
 * @enum {string}
 */
export enum QuoteControllerGetQuoteIncludeDexesEnum {
  Oneinch = 'oneinch',
}
/**
 * @export
 * @enum {string}
 */
export enum QuoteControllerGetQuoteExcludeDexesEnum {
  Oneinch = 'oneinch',
}
/**
 * @export
 * @enum {string}
 */
export enum QuoteControllerGetQuoteIncludeBridgesEnum {
  PolygonBridge = 'polygon-bridge',
  Hop = 'hop',
  AnyswapRouterV4 = 'anyswap-router-v4',
  Hyphen = 'hyphen',
  ArbitrumBridge = 'arbitrum-bridge',
  Connext = 'connext',
}
/**
 * @export
 * @enum {string}
 */
export enum QuoteControllerGetQuoteExcludeBridgesEnum {
  PolygonBridge = 'polygon-bridge',
  Hop = 'hop',
  AnyswapRouterV4 = 'anyswap-router-v4',
  Hyphen = 'hyphen',
  ArbitrumBridge = 'arbitrum-bridge',
  Connext = 'connext',
}
