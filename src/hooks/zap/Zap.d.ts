/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from 'ethers'
import { BytesLike } from '@ethersproject/bytes'
import { Listener, Provider } from '@ethersproject/providers'
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi'
import type { TypedEventFilter, TypedEvent, TypedListener } from './common'

interface ZapInterface extends ethers.utils.Interface {
  functions: {
    'acceptOwner()': FunctionFragment
    'affiliateBalance(address,address)': FunctionFragment
    'affiliateSplit()': FunctionFragment
    'affiliates(address)': FunctionFragment
    'affilliateWithdraw(address[])': FunctionFragment
    'feeTo()': FunctionFragment
    'feeToSetter()': FunctionFragment
    'feeWhitelist(address)': FunctionFragment
    'getSupportedDEX(uint8)': FunctionFragment
    'nativeCurrencyWrapper()': FunctionFragment
    'owner()': FunctionFragment
    'pendingOwner()': FunctionFragment
    'protocolFee()': FunctionFragment
    'removeSupportedDEX(uint8)': FunctionFragment
    'setAffiliateStatus(address,bool)': FunctionFragment
    'setFeeTo(address)': FunctionFragment
    'setFeeToSetter(address)': FunctionFragment
    'setFeeWhitelist(address,bool)': FunctionFragment
    'setNewAffiliateSplit(uint16)': FunctionFragment
    'setOwner(address)': FunctionFragment
    'setProtocolFee(uint16)': FunctionFragment
    'setSupportedDEX(uint8,string,address,address)': FunctionFragment
    'stopped()': FunctionFragment
    'supportedDEXs(uint8)': FunctionFragment
    'toggleContractActive()': FunctionFragment
    'totalAffiliateBalance(address)': FunctionFragment
    'withdrawTokens(address[])': FunctionFragment
    'zapIn((uint256,uint256,uint256,uint8),(uint256,uint256,address[],uint8),(uint256,uint256,address[],uint8),address,address,bool)': FunctionFragment
    'zapOut((uint256,uint256,uint8),(uint256,uint256,address[],uint8),(uint256,uint256,address[],uint8),address,address)': FunctionFragment
  }

  encodeFunctionData(functionFragment: 'acceptOwner', values?: undefined): string
  encodeFunctionData(functionFragment: 'affiliateBalance', values: [string, string]): string
  encodeFunctionData(functionFragment: 'affiliateSplit', values?: undefined): string
  encodeFunctionData(functionFragment: 'affiliates', values: [string]): string
  encodeFunctionData(functionFragment: 'affilliateWithdraw', values: [string[]]): string
  encodeFunctionData(functionFragment: 'feeTo', values?: undefined): string
  encodeFunctionData(functionFragment: 'feeToSetter', values?: undefined): string
  encodeFunctionData(functionFragment: 'feeWhitelist', values: [string]): string
  encodeFunctionData(functionFragment: 'getSupportedDEX', values: [BigNumberish]): string
  encodeFunctionData(functionFragment: 'nativeCurrencyWrapper', values?: undefined): string
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string
  encodeFunctionData(functionFragment: 'pendingOwner', values?: undefined): string
  encodeFunctionData(functionFragment: 'protocolFee', values?: undefined): string
  encodeFunctionData(functionFragment: 'removeSupportedDEX', values: [BigNumberish]): string
  encodeFunctionData(functionFragment: 'setAffiliateStatus', values: [string, boolean]): string
  encodeFunctionData(functionFragment: 'setFeeTo', values: [string]): string
  encodeFunctionData(functionFragment: 'setFeeToSetter', values: [string]): string
  encodeFunctionData(functionFragment: 'setFeeWhitelist', values: [string, boolean]): string
  encodeFunctionData(functionFragment: 'setNewAffiliateSplit', values: [BigNumberish]): string
  encodeFunctionData(functionFragment: 'setOwner', values: [string]): string
  encodeFunctionData(functionFragment: 'setProtocolFee', values: [BigNumberish]): string
  encodeFunctionData(functionFragment: 'setSupportedDEX', values: [BigNumberish, string, string, string]): string
  encodeFunctionData(functionFragment: 'stopped', values?: undefined): string
  encodeFunctionData(functionFragment: 'supportedDEXs', values: [BigNumberish]): string
  encodeFunctionData(functionFragment: 'toggleContractActive', values?: undefined): string
  encodeFunctionData(functionFragment: 'totalAffiliateBalance', values: [string]): string
  encodeFunctionData(functionFragment: 'withdrawTokens', values: [string[]]): string
  encodeFunctionData(
    functionFragment: 'zapIn',
    values: [
      {
        amountAMin: BigNumberish
        amountBMin: BigNumberish
        amountLPMin: BigNumberish
        dexIndex: BigNumberish
      },
      {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      string,
      string,
      boolean
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'zapOut',
    values: [
      {
        amountLpFrom: BigNumberish
        amountTokenToMin: BigNumberish
        dexIndex: BigNumberish
      },
      {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      string,
      string
    ]
  ): string

  decodeFunctionResult(functionFragment: 'acceptOwner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'affiliateBalance', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'affiliateSplit', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'affiliates', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'affilliateWithdraw', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'feeTo', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'feeToSetter', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'feeWhitelist', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getSupportedDEX', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'nativeCurrencyWrapper', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'pendingOwner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'protocolFee', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'removeSupportedDEX', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setAffiliateStatus', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setFeeTo', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setFeeToSetter', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setFeeWhitelist', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setNewAffiliateSplit', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setOwner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setProtocolFee', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setSupportedDEX', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'stopped', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'supportedDEXs', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'toggleContractActive', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'totalAffiliateBalance', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'withdrawTokens', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'zapIn', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'zapOut', data: BytesLike): Result

  events: {
    'OwnerProposal(address)': EventFragment
    'OwnerSet(address)': EventFragment
    'ZapIn(address,address,address,uint256,address,uint256)': EventFragment
    'ZapOut(address,address,address,uint256,address,uint256)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'OwnerProposal'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'OwnerSet'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'ZapIn'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'ZapOut'): EventFragment
}

export type OwnerProposalEvent = TypedEvent<[string] & { _pendingOwner: string }>

export type OwnerSetEvent = TypedEvent<[string] & { _owner: string }>

export type ZapInEvent = TypedEvent<
  [string, string, string, BigNumber, string, BigNumber] & {
    sender: string
    receiver: string
    tokenFrom: string
    amountFrom: BigNumber
    pairTo: string
    amountTo: BigNumber
  }
>

export type ZapOutEvent = TypedEvent<
  [string, string, string, BigNumber, string, BigNumber] & {
    sender: string
    receiver: string
    pairFrom: string
    amountFrom: BigNumber
    tokenTo: string
    amountTo: BigNumber
  }
>

export class Zap extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this

  listeners(eventName?: string): Array<Listener>
  off(eventName: string, listener: Listener): this
  on(eventName: string, listener: Listener): this
  once(eventName: string, listener: Listener): this
  removeListener(eventName: string, listener: Listener): this
  removeAllListeners(eventName?: string): this

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>

  interface: ZapInterface

  functions: {
    acceptOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

    affiliateBalance(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[BigNumber]>

    affiliateSplit(overrides?: CallOverrides): Promise<[number]>

    affiliates(arg0: string, overrides?: CallOverrides): Promise<[boolean]>

    affilliateWithdraw(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    feeTo(overrides?: CallOverrides): Promise<[string]>

    feeToSetter(overrides?: CallOverrides): Promise<[string]>

    feeWhitelist(arg0: string, overrides?: CallOverrides): Promise<[boolean]>

    getSupportedDEX(
      _dexIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { router: string; factory: string }>

    nativeCurrencyWrapper(overrides?: CallOverrides): Promise<[string]>

    owner(overrides?: CallOverrides): Promise<[string]>

    pendingOwner(overrides?: CallOverrides): Promise<[string]>

    protocolFee(overrides?: CallOverrides): Promise<[number]>

    removeSupportedDEX(
      _dexIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setAffiliateStatus(
      _affiliate: string,
      _status: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setFeeTo(_feeTo: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

    setFeeToSetter(
      _feeToSetter: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setFeeWhitelist(
      zapAddress: string,
      status: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setNewAffiliateSplit(
      _newAffiliateSplit: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setOwner(_owner: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

    setProtocolFee(
      _protocolFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    setSupportedDEX(
      _dexIndex: BigNumberish,
      _name: string,
      _router: string,
      _factory: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    stopped(overrides?: CallOverrides): Promise<[boolean]>

    supportedDEXs(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, string] & {
        name: string
        router: string
        factory: string
      }
    >

    toggleContractActive(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

    totalAffiliateBalance(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>

    withdrawTokens(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    zapIn(
      zap: {
        amountAMin: BigNumberish
        amountBMin: BigNumberish
        amountLPMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      transferResidual: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>

    zapOut(
      zap: {
        amountLpFrom: BigNumberish
        amountTokenToMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>
  }

  acceptOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

  affiliateBalance(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>

  affiliateSplit(overrides?: CallOverrides): Promise<number>

  affiliates(arg0: string, overrides?: CallOverrides): Promise<boolean>

  affilliateWithdraw(
    tokens: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  feeTo(overrides?: CallOverrides): Promise<string>

  feeToSetter(overrides?: CallOverrides): Promise<string>

  feeWhitelist(arg0: string, overrides?: CallOverrides): Promise<boolean>

  getSupportedDEX(
    _dexIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, string] & { router: string; factory: string }>

  nativeCurrencyWrapper(overrides?: CallOverrides): Promise<string>

  owner(overrides?: CallOverrides): Promise<string>

  pendingOwner(overrides?: CallOverrides): Promise<string>

  protocolFee(overrides?: CallOverrides): Promise<number>

  removeSupportedDEX(
    _dexIndex: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setAffiliateStatus(
    _affiliate: string,
    _status: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setFeeTo(_feeTo: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

  setFeeToSetter(
    _feeToSetter: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setFeeWhitelist(
    zapAddress: string,
    status: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setNewAffiliateSplit(
    _newAffiliateSplit: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setOwner(_owner: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

  setProtocolFee(
    _protocolFee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  setSupportedDEX(
    _dexIndex: BigNumberish,
    _name: string,
    _router: string,
    _factory: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  stopped(overrides?: CallOverrides): Promise<boolean>

  supportedDEXs(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, string, string] & { name: string; router: string; factory: string }>

  toggleContractActive(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>

  totalAffiliateBalance(arg0: string, overrides?: CallOverrides): Promise<BigNumber>

  withdrawTokens(
    tokens: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  zapIn(
    zap: {
      amountAMin: BigNumberish
      amountBMin: BigNumberish
      amountLPMin: BigNumberish
      dexIndex: BigNumberish
    },
    swapTokenA: {
      amount: BigNumberish
      amountMin: BigNumberish
      path: string[]
      dexIndex: BigNumberish
    },
    swapTokenB: {
      amount: BigNumberish
      amountMin: BigNumberish
      path: string[]
      dexIndex: BigNumberish
    },
    receiver: string,
    affiliate: string,
    transferResidual: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  zapOut(
    zap: {
      amountLpFrom: BigNumberish
      amountTokenToMin: BigNumberish
      dexIndex: BigNumberish
    },
    swapTokenA: {
      amount: BigNumberish
      amountMin: BigNumberish
      path: string[]
      dexIndex: BigNumberish
    },
    swapTokenB: {
      amount: BigNumberish
      amountMin: BigNumberish
      path: string[]
      dexIndex: BigNumberish
    },
    receiver: string,
    affiliate: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>

  callStatic: {
    acceptOwner(overrides?: CallOverrides): Promise<void>

    affiliateBalance(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>

    affiliateSplit(overrides?: CallOverrides): Promise<number>

    affiliates(arg0: string, overrides?: CallOverrides): Promise<boolean>

    affilliateWithdraw(tokens: string[], overrides?: CallOverrides): Promise<void>

    feeTo(overrides?: CallOverrides): Promise<string>

    feeToSetter(overrides?: CallOverrides): Promise<string>

    feeWhitelist(arg0: string, overrides?: CallOverrides): Promise<boolean>

    getSupportedDEX(
      _dexIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { router: string; factory: string }>

    nativeCurrencyWrapper(overrides?: CallOverrides): Promise<string>

    owner(overrides?: CallOverrides): Promise<string>

    pendingOwner(overrides?: CallOverrides): Promise<string>

    protocolFee(overrides?: CallOverrides): Promise<number>

    removeSupportedDEX(_dexIndex: BigNumberish, overrides?: CallOverrides): Promise<void>

    setAffiliateStatus(_affiliate: string, _status: boolean, overrides?: CallOverrides): Promise<void>

    setFeeTo(_feeTo: string, overrides?: CallOverrides): Promise<void>

    setFeeToSetter(_feeToSetter: string, overrides?: CallOverrides): Promise<void>

    setFeeWhitelist(zapAddress: string, status: boolean, overrides?: CallOverrides): Promise<void>

    setNewAffiliateSplit(_newAffiliateSplit: BigNumberish, overrides?: CallOverrides): Promise<void>

    setOwner(_owner: string, overrides?: CallOverrides): Promise<void>

    setProtocolFee(_protocolFee: BigNumberish, overrides?: CallOverrides): Promise<void>

    setSupportedDEX(
      _dexIndex: BigNumberish,
      _name: string,
      _router: string,
      _factory: string,
      overrides?: CallOverrides
    ): Promise<void>

    stopped(overrides?: CallOverrides): Promise<boolean>

    supportedDEXs(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, string] & {
        name: string
        router: string
        factory: string
      }
    >

    toggleContractActive(overrides?: CallOverrides): Promise<void>

    totalAffiliateBalance(arg0: string, overrides?: CallOverrides): Promise<BigNumber>

    withdrawTokens(tokens: string[], overrides?: CallOverrides): Promise<void>

    zapIn(
      zap: {
        amountAMin: BigNumberish
        amountBMin: BigNumberish
        amountLPMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      transferResidual: boolean,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string] & { lpBought: BigNumber; lpToken: string }>

    zapOut(
      zap: {
        amountLpFrom: BigNumberish
        amountTokenToMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string] & { amountTransferred: BigNumber; tokenTo: string }>
  }

  filters: {
    'OwnerProposal(address)'(_pendingOwner?: null): TypedEventFilter<[string], { _pendingOwner: string }>

    OwnerProposal(_pendingOwner?: null): TypedEventFilter<[string], { _pendingOwner: string }>

    'OwnerSet(address)'(_owner?: null): TypedEventFilter<[string], { _owner: string }>

    OwnerSet(_owner?: null): TypedEventFilter<[string], { _owner: string }>

    'ZapIn(address,address,address,uint256,address,uint256)'(
      sender?: null,
      receiver?: null,
      tokenFrom?: null,
      amountFrom?: null,
      pairTo?: null,
      amountTo?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber, string, BigNumber],
      {
        sender: string
        receiver: string
        tokenFrom: string
        amountFrom: BigNumber
        pairTo: string
        amountTo: BigNumber
      }
    >

    ZapIn(
      sender?: null,
      receiver?: null,
      tokenFrom?: null,
      amountFrom?: null,
      pairTo?: null,
      amountTo?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber, string, BigNumber],
      {
        sender: string
        receiver: string
        tokenFrom: string
        amountFrom: BigNumber
        pairTo: string
        amountTo: BigNumber
      }
    >

    'ZapOut(address,address,address,uint256,address,uint256)'(
      sender?: null,
      receiver?: null,
      pairFrom?: null,
      amountFrom?: null,
      tokenTo?: null,
      amountTo?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber, string, BigNumber],
      {
        sender: string
        receiver: string
        pairFrom: string
        amountFrom: BigNumber
        tokenTo: string
        amountTo: BigNumber
      }
    >

    ZapOut(
      sender?: null,
      receiver?: null,
      pairFrom?: null,
      amountFrom?: null,
      tokenTo?: null,
      amountTo?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber, string, BigNumber],
      {
        sender: string
        receiver: string
        pairFrom: string
        amountFrom: BigNumber
        tokenTo: string
        amountTo: BigNumber
      }
    >
  }

  estimateGas: {
    acceptOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>

    affiliateBalance(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>

    affiliateSplit(overrides?: CallOverrides): Promise<BigNumber>

    affiliates(arg0: string, overrides?: CallOverrides): Promise<BigNumber>

    affilliateWithdraw(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    feeTo(overrides?: CallOverrides): Promise<BigNumber>

    feeToSetter(overrides?: CallOverrides): Promise<BigNumber>

    feeWhitelist(arg0: string, overrides?: CallOverrides): Promise<BigNumber>

    getSupportedDEX(_dexIndex: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    nativeCurrencyWrapper(overrides?: CallOverrides): Promise<BigNumber>

    owner(overrides?: CallOverrides): Promise<BigNumber>

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>

    protocolFee(overrides?: CallOverrides): Promise<BigNumber>

    removeSupportedDEX(
      _dexIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setAffiliateStatus(
      _affiliate: string,
      _status: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setFeeTo(_feeTo: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>

    setFeeToSetter(
      _feeToSetter: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setFeeWhitelist(
      zapAddress: string,
      status: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setNewAffiliateSplit(
      _newAffiliateSplit: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setOwner(_owner: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>

    setProtocolFee(
      _protocolFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    setSupportedDEX(
      _dexIndex: BigNumberish,
      _name: string,
      _router: string,
      _factory: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    stopped(overrides?: CallOverrides): Promise<BigNumber>

    supportedDEXs(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>

    toggleContractActive(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>

    totalAffiliateBalance(arg0: string, overrides?: CallOverrides): Promise<BigNumber>

    withdrawTokens(tokens: string[], overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>

    zapIn(
      zap: {
        amountAMin: BigNumberish
        amountBMin: BigNumberish
        amountLPMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      transferResidual: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>

    zapOut(
      zap: {
        amountLpFrom: BigNumberish
        amountTokenToMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>
  }

  populateTransaction: {
    acceptOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>

    affiliateBalance(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>

    affiliateSplit(overrides?: CallOverrides): Promise<PopulatedTransaction>

    affiliates(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>

    affilliateWithdraw(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    feeTo(overrides?: CallOverrides): Promise<PopulatedTransaction>

    feeToSetter(overrides?: CallOverrides): Promise<PopulatedTransaction>

    feeWhitelist(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>

    getSupportedDEX(_dexIndex: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>

    nativeCurrencyWrapper(overrides?: CallOverrides): Promise<PopulatedTransaction>

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>

    protocolFee(overrides?: CallOverrides): Promise<PopulatedTransaction>

    removeSupportedDEX(
      _dexIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setAffiliateStatus(
      _affiliate: string,
      _status: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setFeeTo(_feeTo: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>

    setFeeToSetter(
      _feeToSetter: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setFeeWhitelist(
      zapAddress: string,
      status: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setNewAffiliateSplit(
      _newAffiliateSplit: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setOwner(_owner: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>

    setProtocolFee(
      _protocolFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    setSupportedDEX(
      _dexIndex: BigNumberish,
      _name: string,
      _router: string,
      _factory: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    stopped(overrides?: CallOverrides): Promise<PopulatedTransaction>

    supportedDEXs(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>

    toggleContractActive(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>

    totalAffiliateBalance(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>

    withdrawTokens(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    zapIn(
      zap: {
        amountAMin: BigNumberish
        amountBMin: BigNumberish
        amountLPMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      transferResidual: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>

    zapOut(
      zap: {
        amountLpFrom: BigNumberish
        amountTokenToMin: BigNumberish
        dexIndex: BigNumberish
      },
      swapTokenA: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      swapTokenB: {
        amount: BigNumberish
        amountMin: BigNumberish
        path: string[]
        dexIndex: BigNumberish
      },
      receiver: string,
      affiliate: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>
  }
}
